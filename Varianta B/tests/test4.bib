@InproCEEDiNGs{bogdan2023,
title={O scurta introducere in algebra liniara},
author={Bogdan, Andrei and Sprincenatu, Ionel Tel-Aviv Yafo},
year={2023},


publisher={Politehnica}
}
%asccccccccalalsc
% Prea multe informatii





%           prea multe tab-uri




@ARtiClE{robi2020reviewOnCertainAspects,





title={Sisteme de operare: introducere},
author={Robi, Bogdan and Andrei, Sir Isaac Newton},
volume = 15,
booktitle={2020 intalnire locala la asociatia de locatari},
pages={0588--0592},
year={2020},
number = 2,


organization={BZV AUTO},
journal = {Chiar nu stiu ce as putea sa scriu aici/122:0:1:255},
doi = {15.13424/articol.bine.facut23123}
}
@inproceedings{marian2012,
title={Discutie la alegere},
author={Diana, Andrei Marius and Muchi, Nelson and Mihai, Ciuciulete and Bogdan-Constantin, Manescu and Bogdan, Ioan-Popa Mihai},
booktitle={2010 DRPCIV criza de soferi din cauza examenelor auto prea grele},
pages={00000721--000724},



year=2013,
organization={Care se nimereste, Care se vrea sa fie}
}
%sacascasca
%adscascas
%ascascs
@BOoK{jackLondon1889,
title={Colt Alb si alte opere scrise de el},
author={Jack'London, Charles Dickens},
journal={O poveste de draguta pentru copii},
volume={9},
pages={611--629},
year={2018},
publisher={Adevarul}
}
@BOOK{Yamashita2018convolutional,
title={Convolutional neural networks: an overview and application in radiology},
author={Yamashita, Rikiya and Nishio, Mizuho and Do, Richard Kinh Gian and Togashi, Kaori},
journal={Insights into imaging},
volume={9},





pages={611--629},
year={2018},
publisher={Springer}
}
% Asta-i cel mai lung test dintre toate si sper ca e bun
%   sper...
%       ca
%           n-am omis
%               nimic.









% magic








@aRtIClE{andreibogdidanelu2048,
publisher =  {Android in colaborare cu IOS},
year  =     2005,
journal   =    {Ceva nou::Ceva bun/1224.32::12},
pages     =        {234--451},
author  = {Subsemnatul, Precedentul and B-ogda'n`And'rei, Sprincenatu},
volume = 3,
number = {13},
schumacher = {135::34},
title = {Ceva relevant de preferat dar sunt cam lipsit de inspiratie},
organziation = {ACS-UNSTPB},
doi = {1221.1212.alteC.uvinte343245435},
booktitle = {Pe drumuri de munte},
}








@inregistrare{recorder2009,
camp1 = {Cuvant},
camp2 = {Alte , cuvinte, ce},
numar=     21312,
camp132 = {Vor fi, ignorate},
booktitle = {INexiSTenT!!!},
}




@PHDTHESIS{Andersen1994a,
  author = {Lars Ole Andersen},
  title = {Program Analysis and Specialization for the C Programming Language},
  school = {DIKU, University of Copenhagen},
  year = {1994},
  abstract = {Software engineers are faced with a dilemma. They want to write general
	and wellstructured programs that are flexible and easy to maintain.
	On the other hand, generality has a price: efficiency. A specialized
	program solving a particular problem is often significantly faster
	than a general program. However, the development of specialized software
	is time-consuming, and is likely to exceed the production of today’s
	programmers. New techniques are required to solve this so-called
	software crisis. Partial evaluation is a program specialization technique
	that reconciles the benefits of generality with efficiency. This
	thesis presents an automatic partial evaluator for the Ansi C programming
	language. The content of this thesis is analysis and transformation
	of C programs. We develop several analyses that support the transformation
	of a program into its generating extension. A generating extension
	is a program that produces specialized programs when executed on
	parts of the input. The thesis contains the following main results.},
  spr-prio = {2}
}






% This file was created with JabRef 2.5.
% Encoding: UTF8

@BOOK{Abadi1996,
  title = {A Theory of Objects},
  publisher = {Springer-Verlag New York, Inc.},
  year = {1996},
  author = {Abadi, Martin and Cardelli, Luca},
  address = {Secaucus, NJ, USA},
  abstract = {Procedural languages are generally well understood. Their foundations
	have been cast in calculi that prove useful in matters of implementation
	and semantics. So far, an analogous understanding has not emerged
	for object-oriented languages. In this book the authors take a novel
	approach to the understanding of object-oriented languages by introducing
	object calculi and developing a theory of objects around them. The
	book covers both the semantics of objects and their typing rules,
	and explains a range of object-oriented concepts, such as self, dynamic
	dispatch, classes, inheritance, prototyping, subtyping, covariance
	and contravariance, and method specialization. Researchers and graduate
	students will find this an important development of the underpinnings
	of object-oriented programming.},
  isbn = {0387947752},
  spr-prio = {2},
  url = {http://books.google.co.uk/books?hl=en&lr=&id=4xT3LgCPP5UC&oi=fnd&pg=PR5&dq=A+Theory+of+Objects&ots=9FJDxyQf8J&sig=wBUjlAXPtxADk8_TvuV3DwFudj4#PPP1,M1}
}

@BOOK{Abrahams2004,
  title = {C++ Template Metaprogramming: Concepts, Tools, and Techniques from Boost and Beyond (C++ in Depth Series)},
  publisher = {Addison-Wesley Professional},
  year = {2004},
  author = {Abrahams, David and Gurtovoy, Aleksey},
  abstract = {C++ Template Metaprogramming sheds light on the most powerful idioms
	of today's C++, at long last delivering practical metaprogramming
	tools and techniques into the hands of the everyday programmer.A
	metaprogram is a program that generates or manipulates program code.
	Ever since generic programming was introduced to C++, programmers
	have discovered myriad "template tricks" for manipulating programs
	as they are compiled, effectively eliminating the barrier between
	program and metaprogram. While excitement among C++ experts about
	these capabilities has reached the community at large, their practical
	application remains out of reach for most programmers. This book
	explains what metaprogramming is and how it is best used. It provides
	the foundation you'll need to use the template metaprogramming effectively
	in your own work.This book is aimed at any programmer who is comfortable
	with idioms of the Standard Template Library (STL). C++ power-users
	will gain a new insight into their existing work and a new fluency
	in the domain of metaprogramming. Intermediate-level programmers
	who have learned a few advanced template techniques will see where
	these tricks fit in the big picture and will gain the conceptual
	foundation to use them with discipline. Programmers who have caught
	the scent of metaprogramming, but for whom it is still mysterious,
	will finally gain a clear understanding of how, when, and why it
	works. All readers will leave with a new tool of unprecedented power
	at their disposal-the Boost Metaprogramming Library.The companion
	CD-ROM contains all Boost C++ libraries, including the Boost Metaprogramming
	Library and its reference documentation, along with all of the book's
	sample code and extensive supplementary material.},
  isbn = {0321227255},
  spr-prio = {1}
}

@BOOK{Aho2006,
  title = {Compilers: Principles, Techniques, and Tools (2nd Edition)},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  year = {2006},
  author = {Aho, Alfred V. and Lam, Monica S. and Sethi, Ravi and Ullman, Jeffrey
	D.},
  address = {Boston, MA, USA},
  isbn = {0321486811},
  spr-prio = {1}
}

@BOOK{Alexandrescu2001,
  title = {Modern C++ design: generic programming and design patterns applied},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  year = {2001},
  author = {Alexandrescu, Andrei},
  address = {Boston, MA, USA},
  isbn = {0-201-70431-5},
  spr-prio = {1}
}

@INPROCEEDINGS{Altenkirch2002,
  author = {Thorsten Altenkirch and Conor Mcbride},
  title = {Generic programming within dependently typed programming},
  booktitle = {In Generic Programming, 2003. Proceedings of the IFIP TC2 Working
	Conference on Generic Programming, Schloss Dagstuhl},
  year = {2002},
  pages = {1--20},
  publisher = {Kluwer Academic Publishers},
  abstract = {We show how higher kinded generic programming can be represented faithfully
	within a dependently typed programming system. This development has
	been implemented using the Oleg system. The present work can be seen
	as evidence for our thesis that extensions of type systems can be
	done by programming within a dependently typed language, using data
	as codes for types.},
  citeseerurl = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.101.8558},
  spr-prio = {3}
}

@INPROCEEDINGS{Altenkirch2005,
  author = {Thorsten Altenkirch and Conor Mcbride and James Mckinna},
  title = {Why dependent types matter},
  booktitle = {In preparation, http://www.e-pig.org/downloads/ydtm.pdf},
  year = {2005},
  abstract = {We exhibit the rationale behind the design of Epigram, a dependently
	typed programming language and interactive program development system,
	using refinements of a well known program—merge sort—as a running
	example. We discuss its relationship with other proposals to introduce
	aspects of dependent types into functional programming languages
	and sketch some topics for further work in this area.},
  citeseerurl = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.106.8190},
  spr-prio = {4}
}

@MISC{An2001,
  author = {Ping An and Alin Jula and Silvius Rus and Steven Saunders and Tim
	Smith and Gabriel Tanase and Nathan Thomas and Nancy Amato and Lawrence
	Rauchwerger},
  title = {STAPL: An Adaptive, Generic Parallel C++ Library},
  year = {2001},
  abstract = {The Standard Template Adaptive Parallel Library (STAPL) is a parallel
	library designed as a superset of the ANSI C++ Standard Template
	Library (STL). It is sequentially consistent for functions with the
	same name, and executes on uni- or multi-processor systems that utilize
	shared or distributed memory. STAPL is implemented using simple parallel
	extensions of C++ that currently provide a SPMD model of parallelism,
	and supports nested parallelism. The library is intended to be general
	purpose, but emphasizes irregular programs to allow the exploitation
	of parallelism in areas such as particle transport calculations,
	molecular dynamics, geometric modeling, and graph algorithms, which
	use dynamically linked data structures. STAPL provides several different
	algorithms for some library routines, and selects among them adaptively
	at run-time. STAPL can replace STL automatically by invoking a preprocessing
	translation phase. The performance of translated code is close to
	the results obtained using STAPL directly (less than 5% performance
	deterioration). However, STAPL also provides functionality to allow
	the user to further optimize the code and achieve additional performance
	gains. We present results obtained using STAPL for a molecular dynamics
	code and a particle transport code.},
  owner = {Texas A&M University},
  spr-prio = {3},
  spr-tmp-order = {210}
}
@INPROCEEDINGS{Appukuttan2003a,
  author = {Biju Appukuttan and Tony Clark and Sreedhar Reddy and Laurence Tratt
	and R. Venkatesh},
  title = {A Model Driven Approach to Model Transformations},
  booktitle = {Proc. Model Driven Architecture: Foundations and Applications 2003},
  year = {2003},
  series = {CTIT Technical Report TR--CTIT--03--27},
  month = {June},
  abstract = {The OMG’s Model Driven Architecture (MDA) initiative has been the
	focus of much attention in both academia and industry, due to its
	promise of more rapid and consistent software development through
	the increased use of models. In order for MDA to reach its full potential,
	the ability to manipulate and transform models – most obviously from
	the Platform Independent Model (PIM) to the Platform Specific Models
	(PSM) – is vital. Recognizing this need, the OMG issued a Request
	For Proposals (RFP) largely concerned with finding a suitable mechanism
	for transforming models. This paper outlines the relevant background
	material, summarizes the approach taken by the QVT-Partners (to whom
	the authors belong), presents a non-trivial example using the QVT-Partners
	approach, and finally sketches out what the future holds for model
	transformations.},
  citeseerurl = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.9661},
  spr-prio = {2}
}

@MISC{Appukuttan2003b,
  author = {Biju K. Appukuttan and Tony Clark and Andy Evans and Girish Maskeri
	and Sreedhar Reddy and Paul Sammut and Laurence Tratt and R. Venkatesh
	and James S. Willans},
  title = {{QVT-Partners} initial submission to {QVT} {RFP}},
  month = {March},


  year = {2003},
  note = {OMG document {\ttfamily \relsize{-1} ad/03-03-27}},
  citeseerurl = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.59.8711},
  spr-prio = {3}



  
}
@MISC{Appukuttan2003c,
  author = {Biju K. Appukuttan and Tony Clark and Andy Evans and Girish Maskeri
	and Sreedhar Reddy and Paul Sammut and Laurence Tratt and R. Venkatesh
	and James S. Willans},
  title = {{QVT-Partners} revised submission to {QVT} {RFP}},
  month = {August},
  year = {2003},
  note = {OMG document {\ttfamily \relsize{-1} ad/03-08-08}},
  spr-prio = {3}
}

@TECHREPORT{Appukuttan2002,
  author = {Biju K. Appukuttan and Tony Clark and Andy Evans and Girish Maskeri
	and Paul Sammut and Laurence Tratt and James S. Willans},
  title = {A pattern based approach to defining the dynamic infrastructure of
	UML 2.0},
  year = {2002},
  month = {March},
  abstract = {The 2U Consortium has recently submitted a proposal for the definition
	of the UML 2.0 infrastructure. This uses an innovative technique
	of rapidly “stamping out ” the definition using a small number of
	patterns commonly found in software architecture. The patterns, their
	instantiation, and any further language details are described using
	precise class diagrams and OCL, this enables the definition to be
	easily understood. The main focus of the 2U approach is on the static
	part of the definition. A further concern when modelling software,
	using languages such as the UML, is describing the dynamic behaviour
	of the system over time. The contribution of this paper is to provide
	a template that can be used to “stamp out ” the dynamic part of the
	UML 2.0 infrastructure. We argue for the suitability of the dynamic
	template because it makes little commitment to concrete abstractions
	and can, therefore, be used to support a broad spectrum of behavioural
	languages.},
  booktitle = {Fourth workshop on Rigorous Object Oriented Methods (ROOM)},
  citeseerurl = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.16.7322},
  spr-prio = {4}
}
@MISC{Appukuttan2002a,
  author = {Biju K. Appukuttan and Tony Clark and Andy Evans and Girish Maskeri and 
	Paul Sammut and Laurence Tratt and James S. Willans},
  title = {Unambiguous UML submission to UML 2 Infrastructure {RFP}},
  month = {September},
  year = {2002},
  note = {OMG document ad/2002-06-14},
  spr-prio = {4}
}
@INPROCEEDINGS{Bachmann2006,
  author = {Bachmann, Philipp},
  title = {Static and metaprogramming patterns and static frameworks: a catalog.
	an application},
  booktitle = {PLoP '06: Proceedings of the 2006 conference on Pattern languages
	of programs},
  year = {2006},
  pages = {1--33},
  address = {New York, NY, USA},
  publisher = {ACM},
  abstract = {The classic UNIX principle to write code that generates code instead
	of writing this code yourself [48, Chapters 1, 9] is experiencing
	a revival. Much research was done, the techniques are better understood
	now, and the generation tools were refined.
	
	
	This pattern catalog consists of adaptations of the Gang of Four design
	patterns [27] Abstract Factory, Adapter, Strategy, and Visitor to
	the metaprogramming level. It shows that replacing runtime polymorphism
	by static polymorphism helps to lift variation from the code level
	up to the meta level, where it might more naturally belong to. Some
	of the patterns proposed are especially useful for facilitating portable
	code.
	
	
	The patterns shown can be used to build static Frameworks [50]. A
	simple example is also presented.
	
	
	For all patterns proposed we identified usage examples in popular
	existing applications or libraries.
	
	
	Each pattern presentation is accompanied with an example. These examples
	show sample code in C++. The template metaprogramming capabilities
	of C++ [2, 17, 65] allow us to express both the program and the meta
	program in the same programming language.},
  doi = {http://doi.acm.org/10.1145/1415472.1415492},
  isbn = {978-1-60558-372-3},
  location = {Portland, Oregon},
  spr-prio = {1}
}

@ARTICLE{Bal1998,
  author = {Henri E. Bal and Matthew Haines},
  title = {Approaches for Integrating Task and Data Parallelism},
  journal = {IEEE Concurrency},
  year = {1998},
  volume = {6},
  pages = {74--84},
  abstract = {Languages that support both task and data parallelism are highly general
	and can exploit both forms of parallelism within a single application.
	However, integrating the two forms of parallelism cleanly and within
	a coherent programming model is difficult. This paper describes four
	languages (Fx, Opus, Orca, and Braid) that try to achieve such an
	integration and identifies several problems. The main problems are
	how to support both SPMD and MIMD style programs, how to organize
	the address space of a parallel program, and how to design the integrated
	model such that it can be implemented efficiently.},
  citeseerurl = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.3811},
  spr-prio = {4}
}

@INPROCEEDINGS{Basit2005,
  author = {Hamid Abdul Basit and Damith C. Rajapakse and Stan Jarzabek},
  title = {Beyond templates: a study of clones in the STL and some general implications},
  booktitle = {In ICSE -05: Proceedings of the 27th international conference on
	Software engineering},
  year = {2005},
  pages = {451--459},
  publisher = {ACM Press},
  abstract = {Templates (or generics) help us write compact, generic code, which
	aids both reuse and maintenance. The STL is a powerful example of
	how templates help achieve these goals. Still, our study of the STL
	revealed substantial, and in our opinion, counter-productive repetitions
	(so-called clones) across groups of similar class or function templates.
	Clones occurred, as variations across these similar program structures
	were irregular and could not be unified by suitable template parameters
	in a natural way. We encountered similar problems in other class
	libraries as well as in application programs, written in a range
	of programming languages. In the paper, we present quantitative and
	qualitative results from our study. We argue that the difficulties
	we encountered affect programs in general. We present a solution
	that can treat such template-unfriendly cases of redundancies at
	the meta-level, complementing and extending the power of language
	features, such as templates, in areas of generic programming.},
  citeseerurl = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.63.4939},
  spr-prio = {2}
}